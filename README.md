% Piotr Wojcieszak  
% 2024-10-31  

# Instant compiler
Compiler project for Instant language for JVM and LLVM.

## Compiling and running the program.
We compile the project with a Makefile using the `make` command. The insc_jvm and insc_llvm executables for compiling to JVM and LLVM, respectively, will appear in the root of the project.

In order to run the program, a file with expressions compatible with the Instant grammar must be provided at the program input. Running example:

`./insc_jvm ./examples/test01.ins`

`./insc_llvm ./examples/test01.ins`

After running, files will be generated in the directory where the input file is located:
- .j, .class for insc_jvm
- .ll, .bc for insc_llvm 

## Tools and libraries used
 - BNFC - 2.9.5
 - GHC - 9.4.7
 - LLVM - 18.1.3
 - Java - openjdk 17.0.12
 - Jasmin - 2.3

## Directory structure
```
.
 ├── lib
 │   └── jasmin.jar
 ├── Makefile
 ├── README.md
 └── src
     ├── GeneratorJVM.hs
     ├── GeneratorLLVM.hs
     ├── MainJVM.hs
     ├── MainLLVM.hs
     └── parser
         ├── AbsInstant.hs
         ├── Instant.cf
         ├── LexInstant.hs
         ├── LexInstant.x
         ├── ParInstant.hs
         └── ParInstant.y
```


The /lib directory contains the Jasmin language compiler jar used to generate the .class file.

The /src primarily contains the main runtime files for the compiler:
  - MainJVM.hs, MainLLVM.hs - program entry points passing input files to the parser, calling the generator, creating output files,
  - GeneratorJVM.hs, GeneratorLLVM.hs - AST compilers into JVM/LLVM code.

In /src you will also find the /parser folder with the parser generated by BNFC based on the Instant.cf file contained there. 

After building, the insc_jvm and insc_llvm executable files will appear in the project root. After running the program, .j and .class or .ll and .bc files will be generated in the input file folder.

## Optimizations
### The order of counting subexpressions.
JVM. I always count the subexpression with the higher stack requirement first.

### Elimination of unnecessary swap
JVM. The problem comes from changing the order of subexpression counting. If the node is an operation with a significant order of operators like subtraction and division, I swap the results on the stack with the `swap` command. For addition and multiplication it does not matter, so then I do not execute this command.

### Instruction selection
JVM. In the program I use abbreviated instructions to load constants and variables and write them. In the same way, I use the corresponding functions to insert a value on the stack depending on the size.

### .limit stack
For the JVM `.limit stack` is counted from the bottom. I pass recursively through the tree and, having stopped at the leaf, increase by 1. At the nodes, I compare the stack sizes in both subtrees, choose the one with the larger stack to compute first, and set the node's stack size as the maximum from the tree with the larger stack and the smaller one + 1 (because the left one's result will be on the stack when I pass to it). At the end of the tree transition, I compare its value with the stack maximum for the whole program. In the case of simple processing (consisting of either literals or variables) SExp before the calculation I insert the 'out' field on the stack, so the stack counter has '1' at the start.

### Building the output subtitle
I build the output subtitle (a .j or .ll file) by adding subtitles at the beginning of the output subtitle array (in addition to the header and footer typical of the generated file). At the end, I invert the array and combine its elements. I do this because adding an element to the beginning of the array and reversing them once is much cheaper than adding them at the end.

## Borrowing
Some of the code in MainJVM.hs and MainLLVM.hs is from a BNFC-generated parser test file. This file was a starting point for me, which I modified to my needs. The same is true of the Makefile.
